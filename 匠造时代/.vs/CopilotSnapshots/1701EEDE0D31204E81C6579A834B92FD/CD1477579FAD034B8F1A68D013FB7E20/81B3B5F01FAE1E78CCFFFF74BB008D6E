using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Windows;



public class TerrainSettings
{
    public int width = 512; // 地形网格宽度
    public int height = 512; // 地形网格高度
    public int octaves = 8; // 分形噪声的叠加层数
    public float lacunarity = 2.5f; // 每层噪声频率的增长倍数
    public float gain = 0.4f; // 每层噪声振幅的衰减倍数
    public float scale = 0.05f; // 噪声采样缩放（越小越细腻）
    public float heightScale = 200f; // 地形高度缩放
    public float amplitude = 0.1f; // 振幅
    public float frequency = 0.3f; // 频率

    public TerrainSettings(int width,
        int height,
        int octaves,
        float lacunarity,
        float gain,
        float scale,
        float heightScale,
        float amplitude,
        float frequency)
    {
        this.width = width;
        this.height = height;
        this.octaves = octaves;
        this.lacunarity = lacunarity;
        this.gain = gain;
        this.scale = scale;
        this.heightScale = heightScale;
        this.amplitude = amplitude;
        this.frequency = frequency;
    }
}



[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class WorldGeneration : MonoBehaviour
{
    public GameObject player; // 玩家对象
    public int viewDistance = 4; // 视距（以区块为单位）
    static public int chunkSize = 32; // 区块大小(x*x)
    public int seed; // 世界生成器的种子

    static public Dictionary<string, TerrainSettings> sList = new(){ // （静态）
        { "plain", new(512, 512, 8, 2.5f, 0.4f, 1.0f, 50f, 0.01f, 0.1f) }, // 平原
        { "mountain_range", new(512, 512, 8, 2.5f, 0.4f, 1.0f, 200f, 0.01f, 0.1f) }, // 山脉
        { "hillside", new(512, 512, 8, 2.5f, 0.4f, 0.05f, 200f, 1f, 1f) } // 山坡
    };


    public TerrainSettings s = sList["mountain_range"]; // 山脉

    private Vector2[] loadedChucks = new Vector2[0]; // 已加载的区块

    private void Update()
    {
        int centerX = (int)(player.transform.position.x / chunkSize);
        int centerZ = (int)(player.transform.position.z / chunkSize);
        int rsq = viewDistance; // 视距的平方

        for (int dx = -viewDistance; dx <= viewDistance; dx++)
        {
            for (int dz = -viewDistance; dz <= viewDistance; dz++)
            {
                if (dx * dx + dz * dz <= rsq)
                {
                    int chunkX = centerX + dx;
                    int chunkZ = centerZ + dz;
                    // 在这里处理(chunkX, chunkZ)区块
                    Debug.Log($"{chunkX}, {chunkZ}");
                    if (!loadedChucks.Contains(new Vector2(chunkX, chunkZ)))
                    {
                        loadedChucks.Append(new Vector2(chunkX, chunkZ));
                        Generation(chunkX * chunkSize, chunkZ * chunkSize);
                    }
                }
            }
        }
    }


    // 修正Generation方法中的顶点和三角形索引越界问题
    void Generation(int vx, int vy)
    {
        // 创建噪声生成器
        FastNoiseLite noise = new(seed);
        noise.SetNoiseType(FastNoiseLite.NoiseType.OpenSimplex2);

        // 顶点、UV和三角形索引数组
        Vector3[] vertices = new Vector3[chunkSize * chunkSize];
        Vector2[] uvs = new Vector2[chunkSize * chunkSize];
        int[] triangles = new int[(chunkSize - 1) * (chunkSize - 1) * 6];

        // 修正循环范围，确保x和y都从0到chunkSize-1
        for (int y = 0; y < chunkSize; y++)
        {
            for (int x = 0; x < chunkSize; x++)
            {
                float amplitude = s.amplitude; // 振幅
                float frequency = s.frequency; // 频率
                float value = 0f;
                float max = 0f;
                // 分形噪声叠加
                for (int o = 0; o < s.octaves; o++)
                {
                    float nx = (vx + x) * s.scale * frequency;
                    float ny = (vy + y) * s.scale * frequency;
                    value += noise.GetNoise(nx, ny) * amplitude;
                    max += amplitude;
                    amplitude *= s.gain;
                    frequency *= s.lacunarity;
                }
                value /= max; // 归一化噪声值
                int idx = y * chunkSize + x;
                vertices[idx] = new Vector3(vx + x, value * s.heightScale, vy + y); // 设置顶点坐标
                uvs[idx] = new Vector2((float)x / (chunkSize - 1), (float)y / (chunkSize - 1)); // 设置UV
            }
        }

        //生成三角形索引（每个格子两个三角形）
        int tri = 0;
        for (int y = 0; y < chunkSize - 1; y++)
        {
            for (int x = 0; x < chunkSize - 1; x++)
            {
                int idx = y * chunkSize + x;
                // 顺时针两个三角形
                triangles[tri++] = idx;
                triangles[tri++] = idx + chunkSize;
                triangles[tri++] = idx + 1;

                triangles[tri++] = idx + 1;
                triangles[tri++] = idx + chunkSize;
                triangles[tri++] = idx + chunkSize + 1;
            }
        }

        // 创建Mesh并赋值
        Mesh mesh = new();
        mesh.indexFormat = (chunkSize * chunkSize > 65000) ? UnityEngine.Rendering.IndexFormat.UInt32 : mesh.indexFormat;
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.uv = uvs;
        mesh.RecalculateNormals();
        mesh.RecalculateTangents();

        // 赋值给MeshFilter
        MeshFilter mf = GetComponent<MeshFilter>();
        mf.mesh = mesh;

        // 赋值给MeshCollider，实现地形碰撞
        MeshCollider mc = GetComponent<MeshCollider>();
        if (mc == null)
            mc = gameObject.AddComponent<MeshCollider>();
        mc.sharedMesh = null;
        mc.sharedMesh = mesh;

        // 自动赋予Standard材质（如未设置材质）
        var mr = GetComponent<MeshRenderer>();
        if (mr.sharedMaterial == null)
        {
            mr.material = new Material(Shader.Find("Standard"))
            {
                color = Color.green
            };
        }
    }

    void Start()
    {
        if (player == null)
        {
            throw new ArgumentNullException("在 WorldGeneration 中未指定玩家对象！");
        }

        // 获取 Int 范围内随机种子
        System.Random random = new();
        seed = random.Next(2) == 0 ? random.Next(int.MinValue, 0) : random.Next(0, int.MaxValue);
    }
}
