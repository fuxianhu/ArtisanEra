# 世界生成

世界生成包含地形生成和结构生成，**不包含**生物生成等不在开始加载时做的事。

游戏中使用了大量 `System.Random` （生成 `Int` 和 `Float` 随机数）和第三方库 `FastNoiseLite.cs` （生成柏林噪声）。

## 地形生成

### 多层柏林噪声（分形噪声）

使用Ken Perlin发明的自然噪声生成算法——[柏林噪声（点击前往百度百科）](https://baike.baidu.com/item/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/3366096)生成连续且自然的地形，使用 $ noise(x, y) $ $2$ 维柏林噪声函数与正切函数 $\sin(x)$ 叠加实现多层柏林噪声（即**分形噪声**或**域扭曲**）。

第一层柏林噪声使用**低频**、**高振幅**的噪声，接下来每一层的噪声**频率更高**、**振幅更低**，从总体上的大致形状到细节。

其有 $3$ 个参数：
- **Octaves（倍频/层数）**：要叠加的噪声**层数量**。
- **Persistence（持久度）**：控制每一层**振幅的衰减率**。值越**小**，后续层的影响越弱，最终结果越**平滑**。
- **Lacunarity（间隙度）**：控制每一层**频率的增长率**。值越**大**，后续层的细节越“**密集**”。

### 具体的生成和渲染

了解了地形生成算法，我们就可以将其应用到实际项目中，但这与前面的理论有一些不同，且实际代码会进行**一些优化**。（有关其实现细节见代码及其注释）

实际我们应该以玩家坐标为原点 $O$， 半径为 $viewDistance$ （视野距离）的**球**内渲染，视野距离之外不再渲染。

我们可以在这个球内从里到外渲染，首先创建许多**点**构成**点阵**，根据 $ noise(x, y) $ 的结果确定其 $y$ 轴，然后每 $3$ 个点渲染一个三角形。

> [!NOTE]
> 这段内容省去了很多优化细节，比如距离越远三角形的渲染量越小、通过各种方法降低内存占用、提高帧率，有关其实现细节见代码及其注释。

## 结构生成

### 树木生成

使用多个预制的树Prefab，对于每棵树，随机选用一个Prefab渲染。相较于程序化生成树木，失去了多样性，但提升性能，且不会生成形状奇怪的树木。

游戏会连续地生成一些相同种类的树木，但有概率几种不同的树木会挨得很近，或者大面积的 $2$ 种树木相结合，这取决于噪声值和群系。

树不得生成在 $y < -100$ 或 $y > 180$ 的位置，且要有足够的上方空间，且生成处必须是泥土，所有树不得生成在流体中，但水杉树必须生成在水中。

种类：

### 流体生成（敬请期待）

#### 水体生成（敬请期待）

#### 熔岩生成（敬请期待）

### 迷宫生成（敬请期待）

## 参考资料与友情链接

- [【此视频为搬运与翻译】强大的山地生成算法(非柏林噪声和侵蚀算法)](https://www.bilibili.com/video/BV1CZ421i7qu/)
- [【此视频为搬运与翻译】优化游戏性能：地形和LOD技术 - Vercidium](https://www.bilibili.com/video/BV1wA4m1c7sj/)
- [【Voidmatrix】全是骚操作？这可能是最简单的地牢生成算法！ 【游戏开发秘籍】](https://www.bilibili.com/video/BV1fgWtzXE8i/)
- [【Sli97】《地图随机生成》柏林噪声算法如何实现游戏世界](https://www.bilibili.com/video/BV19f42197ME)